{
  "hash": "54a96c9ab190850e82848ffd22880069",
  "result": {
    "engine": "knitr",
    "markdown": "# Covariate modeling with brms\n\nThe previous chapter introduced the brms approach to Bayesian E~max~ modeling, with examples provided for hyperbolic and sigmoidal E~max~ models, and considering both continuous and binary outcomes. This chapter extends this by building models that include covariates, and shows examples of model comparison using leave-one-out cross-validation (LOO-CV).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(posterior)\nlibrary(tidybayes)\nlibrary(here)\nlibrary(BayesERtools)\n\ntheme_set(theme_bw(base_size = 12))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (require(cmdstanr)) {\n  # prefer cmdstanr and cache binaries\n  options(\n    brms.backend = \"cmdstanr\", \n    cmdstanr_write_stan_file_dir = here(\"_brms-cache\")\n  )\n  dir.create(here(\"_brms-cache\"), FALSE)\n} else {\n  rstan::rstan_options(auto_write = TRUE)\n}\n```\n\n<pre class=\"r-output\"><code>Loading required package: cmdstanr\n</code></pre><pre class=\"r-output\"><code>This is cmdstanr version 0.9.0\n</code></pre><pre class=\"r-output\"><code>- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n</code></pre><pre class=\"r-output\"><code>- CmdStan path: /home/danielle/.cmdstan/cmdstan-2.36.0\n</code></pre><pre class=\"r-output\"><code>- CmdStan version: 2.36.0\n</code></pre>\n:::\n\n\n\n\n## Continuous response with covariates\n\nThe simulated data set contains three continuous covariates (`cnt_a`, `cnt_b`, and `cnt_c`) that may be related to the continuous oucome `response_1`. The univariate relationships between each covariate and the response are shown below, along with the relationship between `exposure` and `reponse_1`: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_sim_emax |> \n  pivot_longer(\n    cols = c(exposure, cnt_a, cnt_b, cnt_c), \n    names_to = \"variable\",\n    values_to = \"value\"\n  ) |> \n  ggplot(aes(value, response_1)) + \n  geom_point() + \n  geom_smooth(formula = y ~ x, method = \"loess\") + \n  facet_wrap(~ variable, scales = \"free_x\")\n```\n\n::: {.cell-output-display}\n![](covariate_modeling_files/figure-html/show-continuous-emax-data-1.png){width=768}\n:::\n:::\n\n\n\n\nIn the brms framework, the E~max~ function is treated as a structural model and covariates can be placed on any parameter when the model is specified using `brmsformula()`. As an example, the model specified here sets `cnt_a`, `cnt_b`, and `cnt_c` as covariates on the baseline response:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncovariate_model_1 <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure), # structural model\n  e0   ~ 1 + cnt_a + cnt_b + cnt_c, # covariate model for baseline\n  emax ~ 1,                         # covariate model for max response\n  ec50 ~ 1,                         # covariate model for EC50\n  nl = TRUE\n)\n```\n:::\n\n\n\n\nThe measurement model and parameter prior are specified using `brmsfamily()` and `prior()`, and are the same as for the model without covariates:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngaussian_measurement <- brmsfamily(\n  family = \"gaussian\", \n  link = \"identity\"\n)\n\nparameter_prior <- c(\n  prior(normal(0, 1.5), nlpar = \"e0\"),\n  prior(normal(0, 1.5), nlpar = \"emax\"),\n  prior(normal(2000, 500), nlpar = \"ec50\", lb = 0)\n)\n```\n:::\n\n\n\n\nWhen interpreting the prior, it is important to remember that there are covariates on `e0`: the `normal(0, 1.5)` prior is applied to all regression coefficients. That means that this prior is applied independently to `e0_Intercept`, `e0_cnt_a`, `e0_cnt_b`, and `e0_cnt_c`. \n\nTo apply this model to the continuous data, pass all three of these to `brm()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_covariate_fit <- brm(\n  formula = covariate_model_1, \n  family = gaussian_measurement, \n  data = d_sim_emax, \n  prior = parameter_prior\n) \n```\n:::\n\n\n\n\nPrinting the `continuous_covariate_fit` object provides summary information about the regression coefficients for the covariates and other parameters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_covariate_fit\n```\n\n<pre class=\"r-output\"><code> Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: response_1 ~ e0 + emax * exposure/(ec50 + exposure) \n         e0 ~ 1 + cnt_a + cnt_b + cnt_c\n         emax ~ 1\n         ec50 ~ 1\n   Data: d_sim_emax (Number of observations: 300) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ne0_Intercept       4.13      0.47     3.14     4.98 1.00     1049     1431\ne0_cnt_a           0.51      0.01     0.49     0.54 1.00     3683     3141\ne0_cnt_b          -0.01      0.01    -0.04     0.01 1.00     2945     2920\ne0_cnt_c           0.00      0.01    -0.02     0.03 1.00     3405     2529\nemax_Intercept    10.70      0.42     9.95    11.61 1.01     1102     1391\nec50_Intercept  3324.06    296.63  2765.73  3936.94 1.00     1106     1601\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.50      0.02     0.46     0.54 1.00     3268     2817\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n</code></pre>\n:::\n\n\n\n\nExtending the data visualization used earlier, the model predictions can be plotted as a function of both `exposure` and `cnt_a`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncnt_a_map <- \n  tibble(\n    cnt_a = c(2, 5, 8),\n    cnt_a_group = c(\"2 (<3.5)\", \"5 (3.5~6.5)\", \"8 (≥6.5)\")\n  )\n\nsim_exposure_cnt_a <- \n  continuous_covariate_fit |> \n  epred_draws(newdata = expand_grid(\n    exposure = seq(0, 50000, 1000),\n    cnt_a = c(2, 5, 8), \n    cnt_b = 5,\n    cnt_c = 5\n  )) |> \n  median_qi() |> \n  left_join(cnt_a_map, by = join_by(cnt_a))\n\nd_for_plot <- \n  d_sim_emax |> \n  mutate(\n    cnt_a_raw = cnt_a,\n    cnt_a = case_when(\n      cnt_a < 3.5 ~ 2,\n      cnt_a >= 3.5 & cnt_a < 6.5 ~ 5,\n      cnt_a >= 6.5 ~ 8\n    )\n  ) |> \n  left_join(cnt_a_map, by = join_by(cnt_a))\n\nsim_exposure_cnt_a |> \n  ggplot(mapping = aes(exposure, .epred)) + \n  geom_path() + \n  geom_ribbon(\n    mapping = aes(ymin = .lower, ymax = .upper), \n    alpha = 0.3\n  ) +\n  geom_point(\n    data = d_for_plot,\n    mapping = aes(y = response_1, color = cnt_a_raw)\n  ) + \n  facet_wrap(~cnt_a_group, labeller = label_both) +\n  labs(color = \"cnt_a\") + \n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](covariate_modeling_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n## Binary response with covariates\n\nBuilding a covariate model for binary response data follows the same process as for continuous response data. As before, exploratory visualizations are helpful in illustrating the relationships between covariates and the binary `response_2` variable:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_sim_emax |> \n  pivot_longer(\n    cols = c(exposure, cnt_a, cnt_b, cnt_c), \n    names_to = \"variable\",\n    values_to = \"value\"\n  ) |> \n  mutate(response_2 = factor(response_2)) |> \n  ggplot(aes(response_2, value)) + \n  geom_violin(draw_quantiles = .5) + \n  facet_wrap(~ variable, scales = \"free_y\")\n```\n\n::: {.cell-output-display}\n![](covariate_modeling_files/figure-html/show-binary-emax-data-1.png){width=768}\n:::\n:::\n\n\n\n\nAs in the previous chapter, the primary difference between the binary model and the continuous model is the use of the `bernoulli_measurement` model:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbernoulli_measurement <- brmsfamily(\n  family = \"bernoulli\", \n  link = \"logit\"\n)\n```\n:::\n\n\n\n\nThe actal models specification `covariate_model_2` differs only in that it indicates that the binary outcome `response_2` is used\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncovariate_model_2 <- brmsformula(\n  response_2 ~ e0 + emax * exposure / (ec50 + exposure), # structural model\n  e0   ~ 1 + cnt_a + cnt_b + cnt_c, # covariate model for baseline\n  emax ~ 1,                         # covariate model for max response\n  ec50 ~ 1,                         # covariate model for EC50\n  nl = TRUE\n)\n```\n:::\n\n\n\n\nThe `parameter_prior` is the same as before. All three are passed to `brm()`, as shown below: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbinary_covariate_fit <- brm(\n  formula = covariate_model_2, \n  family = bernoulli_measurement, \n  data = d_sim_emax, \n  prior = parameter_prior\n) \n```\n:::\n\n\n\n\nAfter the sampling finishes, printing the model fit object shows parameter estimates and details about the behavior of the sampler:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbinary_covariate_fit\n```\n\n<pre class=\"r-output\"><code> Family: bernoulli \n  Links: mu = logit \nFormula: response_2 ~ e0 + emax * exposure/(ec50 + exposure) \n         e0 ~ 1 + cnt_a + cnt_b + cnt_c\n         emax ~ 1\n         ec50 ~ 1\n   Data: d_sim_emax (Number of observations: 300) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ne0_Intercept      -2.78      0.83    -4.41    -1.16 1.00     2031     2458\ne0_cnt_a           0.53      0.08     0.38     0.69 1.00     2563     2518\ne0_cnt_b          -0.01      0.06    -0.14     0.12 1.00     3404     2919\ne0_cnt_c          -0.19      0.07    -0.32    -0.06 1.00     3574     3044\nemax_Intercept     3.28      0.91     1.48     5.08 1.00     2487     2733\nec50_Intercept  2458.06    440.92  1619.03  3327.95 1.00     3585     2739\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n</code></pre>\n:::\n\n\n\n\nThe data visualization for this model is shown below:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncnt_a_map <- \n  tibble(\n    cnt_a = c(2, 5, 8),\n    cnt_a_group = c(\"2 (<3.5)\", \"5 (3.5~6.5)\", \"8 (≥6.5)\")\n  )\n\nsim_exposure_cnt_a <- \n  binary_covariate_fit |> \n  epred_draws(newdata = expand_grid(\n    exposure = seq(0, 50000, 1000),\n    cnt_a = c(2, 5, 8), \n    cnt_b = 5,\n    cnt_c = 5\n  )) |> \n  median_qi() |> \n  left_join(cnt_a_map, by = join_by(cnt_a))\n\nd_for_plot <- \n  d_sim_emax |> \n  mutate(\n    cnt_a_raw = cnt_a,\n    cnt_a = case_when(\n      cnt_a < 3.5 ~ 2,\n      cnt_a >= 3.5 & cnt_a < 6.5 ~ 5,\n      cnt_a >= 6.5 ~ 8\n    )\n  ) |> \n  left_join(cnt_a_map, by = join_by(cnt_a))\n\nsim_exposure_cnt_a |> \n  ggplot(mapping = aes(exposure, .epred)) + \n  geom_path() + \n  geom_ribbon(\n    mapping = aes(ymin = .lower, ymax = .upper), \n    alpha = 0.3\n  ) +\n  geom_jitter(\n    data = d_for_plot,\n    mapping = aes(y = response_2, color = cnt_a_raw),\n    width = 0,\n    height = .05\n  ) + \n  facet_wrap(~cnt_a_group, labeller = label_both) +\n  labs(color = \"cnt_a\") + \n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](covariate_modeling_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n## Setting covariates on other parameters\n\nThe previous two examples illustrate covariates placed on the intercept parameter `e0`. It is possible to define covariate models on any parameter within the E~max~ model. Returning to the continuous outcome `response_1`, the model is specified as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nother_covariates <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure), # structural model\n  e0   ~ 1 + cnt_a,   # covariate model for baseline\n  emax ~ 1 + cnt_b,   # covariate model for max response\n  ec50 ~ 1,           # covariate model for EC50\n  nl = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nother_covariates_fit <- brm(\n  formula = other_covariates, \n  family = gaussian_measurement, \n  data = d_sim_emax, \n  prior = parameter_prior\n) \n```\n:::\n\n\n\n\nPrinting the `other_covariates_fit` object provides summary information:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nother_covariates_fit\n```\n\n<pre class=\"r-output\"><code> Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: response_1 ~ e0 + emax * exposure/(ec50 + exposure) \n         e0 ~ 1 + cnt_a\n         emax ~ 1 + cnt_b\n         ec50 ~ 1\n   Data: d_sim_emax (Number of observations: 300) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ne0_Intercept       4.10      0.46     3.11     4.92 1.00     1247     1297\ne0_cnt_a           0.51      0.01     0.49     0.54 1.00     3027     2684\nemax_Intercept    10.70      0.42     9.95    11.60 1.00     1297     1391\nemax_cnt_b        -0.01      0.02    -0.04     0.03 1.00     2619     2604\nec50_Intercept  3328.33    289.13  2777.47  3909.33 1.00     1418     1664\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.50      0.02     0.46     0.54 1.00     2635     2023\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n</code></pre>\n:::\n\n\n\n\n## Model comparison\n\nThe brms package provides a flexible interface for model comparison using LOO-CV and WAIC, using the [loo](http://mc-stan.org/loo/) package internally. One workflow for calling this interface is illustrated in this section, using the three possible E~max~ models as examples: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# no covariates\nbase_model <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure),\n  e0   ~ 1,\n  emax ~ 1,\n  ec50 ~ 1,\n  nl = TRUE\n)\n\n# one predictor on e0\ncnt_a_model <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure),\n  e0   ~ 1 + cnt_a,\n  emax ~ 1,\n  ec50 ~ 1,\n  nl = TRUE\n)\n\n# three predictors on e0\ncnt_abc_model <- brmsformula(\n  response_1 ~ e0 + emax * exposure / (ec50 + exposure),\n  e0   ~ 1 + cnt_a + cnt_b + cnt_c,\n  emax ~ 1,\n  ec50 ~ 1,\n  nl = TRUE\n)\n```\n:::\n\n\n\n\nIn addition to calling `brm()` to estimate regression coefficients, the `add_criterion()` function is called to run the LOO-CV procedure and store the results internally within the brmsfit object:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_fit <- base_model |> \n  brm(  \n    family = gaussian_measurement, \n    data = d_sim_emax, \n    prior = parameter_prior\n  ) |> \n  add_criterion(\"loo\")\n  \ncnt_a_fit <- cnt_a_model |> \n  brm(\n    family = gaussian_measurement, \n    data = d_sim_emax, \n    prior = parameter_prior\n  ) |> \n  add_criterion(\"loo\")\n\ncnt_abc_fit <- cnt_abc_model |> \n  brm(\n    family = gaussian_measurement, \n    data = d_sim_emax, \n    prior = parameter_prior\n  ) |> \n  add_criterion(\"loo\")\n```\n:::\n\n\n\n\nTo compare models that have LOO criteria information added, use `loo_compare()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_comparison <- loo_compare(\n  base_fit,\n  cnt_a_fit,\n  cnt_abc_fit\n)\n\nmodel_comparison\n```\n\n<pre class=\"r-output\"><code>            elpd_diff se_diff\ncnt_a_fit      0.0       0.0 \ncnt_abc_fit   -1.6       0.9 \nbase_fit    -283.3      15.4 \n</code></pre>\n:::\n\n\n\n\nIn this example, `cnt_a_fit` model outperforms the other two models. \n\nBy default the printed output shows the most important columns, but the return value from `loo_compare()` contains additional information relevant to the model comparison. To view all columns, call the print method with `simplify = FALSE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(model_comparison, simplify = FALSE)\n```\n\n<pre class=\"r-output\"><code>            elpd_diff se_diff elpd_loo se_elpd_loo p_loo  se_p_loo looic \ncnt_a_fit      0.0       0.0  -216.7     13.1         4.5    0.5    433.4\ncnt_abc_fit   -1.6       0.9  -218.3     13.3         6.6    0.7    436.6\nbase_fit    -283.3      15.4  -500.0     11.4         2.8    0.3   1000.0\n            se_looic\ncnt_a_fit     26.3  \ncnt_abc_fit   26.5  \nbase_fit      22.8  \n</code></pre>\n:::\n",
    "supporting": [
      "covariate_modeling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}