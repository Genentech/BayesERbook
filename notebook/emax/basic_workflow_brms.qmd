# Basic workflow with brms

The [brms](https://paulbuerkner.com/brms/) package provides a flexible framework for specifying multilevel regression models, using Stan as the back end. It is typically used for models within the generalized linear mixed model (GLMM) specification, but can accommodate nonlinear models such as E~max~. This chapter uses the brms package to develop and evaluate Bayesian E~max~ regression. Models for continuous and binary response data are discussed, and in the next chapter these are extended to include covariates.

```{r}
#| output: FALSE
#| message: FALSE

library(tidyverse)
library(brms)
library(posterior)
library(tidybayes)
library(here)

theme_set(theme_bw(base_size = 12))
```

```{r}
#| include: FALSE
# Enable colored outputs
source(here("R", "cli_color_text.R"))
```

## Continuous E~max~ models 

This section shows how to build a simple E~max~ model for continuous response data using brms. The extension to binary response data is discussed in the next section. To build the model a simulated data set is used. In addition to an `exposure` column and a continuous `response` column, there are three continuous covariates that may be related to the response and will be used in the next chapter:

```{r}
#| message: FALSE
d_example_emax_3cov <- read_csv(here("data", "d_example_emax_3cov.csv"))
d_example_emax_3cov
```

To examine the structure of the data set, create an exploratory visualization:

```{r}
#| label: show-continuous-emax-data
#| fig-height: 8
#| fig-width: 8

d_example_emax_3cov |> 
  pivot_longer(
    cols = c(exposure, cov_a, cov_b, cov_c), 
    names_to = "variable",
    values_to = "value"
  ) |> 
  ggplot(aes(value, response)) + 
  geom_point() + 
  geom_smooth(formula = y ~ x, method = "loess") + 
  facet_wrap(~ variable, scales = "free_x")
```

Initially we will build a model that does not consider the covariates. To specify a regular E~max~ model in brms, use `brmsformula()` to describe the exposure-response relationship, setting `nl = TRUE` to ensure that brms interprets the input as a non-linear model:

```{r}
#| label: simple-continuous-emax-model
base_model <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure),
  e0 ~ 1,
  emax ~ 1,
  ec50 ~ 1,
  nl = TRUE
) 
```

In this specification, the first formula indicates that the exposure-response relationship is an E~max~ function. The later formulas indicate that `e0`, `emax`, and `ec50` are model parameters.

Assumptions must also be specified for the distribution of measurement errors. For simplicity, this example assumes errors are normally distributed. Use the `brmsfamily()` function to specify this:

```{r}
#| label: gaussian-error-model
gaussian_measurement <- brmsfamily(
  family = "gaussian", 
  link = "identity"
)
```

Parameter priors for `e0`, `emax`, and `ec50` must also be specified. In brms the default is to place an improper flat prior on regression parameters. For this example a weakly-informative prior is used. The `prior()` function is used for this, using the `nlpar` argument to specify the name of a non-linear parameter, and using `lb` and `ub` to impose lower and upper bounds if required:

```{r}
parameter_prior <- c(
  prior(normal(0, 1.5), nlpar = "e0"),
  prior(normal(0, 1.5), nlpar = "emax"),
  prior(normal(2000, 500), nlpar = "ec50", lb = 0)
)
```

These three components are then passed to `brm()` to estimate model parameters:

```{r}
#| label: run-continuous-emax-model
#| message: false
#| results: hide
continuous_base_fit <- brm(
  formula = base_model, 
  family = gaussian_measurement, 
  data = d_example_emax_3cov, 
  prior = parameter_prior
) 
```

When this code is executed a Stan model is compiled and run, and detailed information on the sampling is printed during the run. At the end, inspect the brms model object to obtain a summary of the model, the sampling, and the parameter estimates:

```{r}
continuous_base_fit
```

The data can be visualized in many different ways. A simple example is shown below, using `epred_draws()` to extract model predictions as a function of exposure:

```{r}
continuous_base_fit |> 
  epred_draws(newdata = tibble(exposure = seq(0, 50000, 1000))) |> 
  summarize(response = mean(.epred), .groups = "drop") |> 
  ggplot(mapping = aes(exposure, response)) + 
  geom_path() + 
  geom_point(data = d_example_emax_3cov)
```

## Binary E~max~ models 

The data set with binary response data is identical to the continuous data apart from the `response` variable, which is now 0 or 1 for each subject:

```{r}
#| message: FALSE
d_example_emax_bin_3cov <- read_csv(here("data", "d_example_emax_bin_3cov.csv"))
d_example_emax_bin_3cov
```

To examine the structure of the data set, create an exploratory visualization:

```{r}
#| label: show-binary-emax-data
#| fig-height: 8
#| fig-width: 8

d_example_emax_bin_3cov |> 
  pivot_longer(
    cols = c(exposure, cov_a, cov_b, cov_c), 
    names_to = "variable",
    values_to = "value"
  ) |> 
  mutate(response = factor(response)) |> 
  ggplot(aes(response, value)) + 
  geom_violin(draw_quantiles = .5) + 
  facet_wrap(~ variable, scales = "free_y")
```

To adapt the brms model to be appropriate for binary responses, the measurement model is adjusted. As in logistic regression, binary responses are assumed to be Bernoulli distributed, with a logit link function:

```{r}
#| label: bernoulli-error-model
bernoulli_measurement <- brmsfamily(
  family = "bernoulli", 
  link = "logit"
)
```

This is the only modification required: the `parameter_prior` and `base_model` are both unchanged. To estimate parameters, call `brm()` for the binary data set using the `bernoulli_measurement` family:

```{r}
#| label: run-binary-emax-model
#| message: false
#| results: hide
binary_base_fit <- brm(
  formula = base_model, 
  family = bernoulli_measurement, 
  data = d_example_emax_bin_3cov, 
  prior = parameter_prior
) 
```

Again, inspect the model fit object to see the results:

```{r}
binary_base_fit
```

The predictions of the fitted model are visualized below:

```{r}
binary_base_fit |> 
  epred_draws(newdata = tibble(exposure = seq(0, 50000, 1000))) |> 
  summarize(response = mean(.epred), .groups = "drop") |> 
  ggplot(mapping = aes(exposure, response)) + 
  geom_path() + 
  geom_jitter(data = d_example_emax_bin_3cov, width = 0, height = .05)
```

