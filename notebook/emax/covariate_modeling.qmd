# Covariate modeling with brms

The [brms](https://paulbuerkner.com/brms/) package provides a flexible framework for specifying multilevel regression models, using Stan as the back end. It is typically used for models within the generalized linear mixed model (GLMM) specification, but can accommodate nonlinear models such as E~max~. This chapter uses the brms package to develop and evaluate Bayesian E~max~ regression models with and without covariates. Models for continuous and binary response data are discussed. 

```{r}
#| output: FALSE
#| message: FALSE

library(tidyverse)
library(brms)
library(posterior)
library(tidybayes)
library(here)

theme_set(theme_bw(base_size = 12))
```

```{r}
#| include: FALSE
# Enable colored outputs
source(here("R", "cli_color_text.R"))
```

```{r}
#| label: previous-chapter
#| message: false
#| results: hide

# load data
d_example_emax_3cov <- read_csv(here("data", "d_example_emax_3cov.csv"))
d_example_emax_bin_3cov <- read_csv(here("data", "d_example_emax_bin_3cov.csv"))

# model specification
base_model <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure),
  e0 ~ 1,
  emax ~ 1,
  ec50 ~ 1,
  nl = TRUE
)

# gaussian measurement for continuous data
gaussian_measurement <- brmsfamily(
  family = "gaussian", 
  link = "identity"
)

# bernoulli maeasurement for binary data
bernoulli_measurement <- brmsfamily(
  family = "bernoulli", 
  link = "logit"
)

# parameter prior
parameter_prior <- c(
  prior(normal(0, 1.5), nlpar = "e0"),
  prior(normal(0, 1.5), nlpar = "emax"),
  prior(normal(2000, 500), nlpar = "ec50", lb = 0)
)

# base model for continuous data, no covariates
continuous_base_fit <- brm(
  formula = base_model, 
  family = gaussian_measurement, 
  data = d_example_emax_3cov, 
  prior = parameter_prior
) 

# base model for binary data, no covariates
binary_base_fit <- brm(
  formula = base_model, 
  family = bernoulli_measurement, 
  data = d_example_emax_bin_3cov, 
  prior = parameter_prior
) 
```


To examine the structure of the data set, create an exploratory visualization:

```{r}
#| label: show-continuous-emax-data
#| fig-height: 8
#| fig-width: 8

d_example_emax_3cov |> 
  pivot_longer(
    cols = c(exposure, cov_a, cov_b, cov_c), 
    names_to = "variable",
    values_to = "value"
  ) |> 
  ggplot(aes(value, response)) + 
  geom_point() + 
  geom_smooth(formula = y ~ x, method = "loess") + 
  facet_wrap(~ variable, scales = "free_x")
```


## Adding covariates

In the brms framework, the E~max~ function is treated as a structural model and covariates can be placed on any parameter. As an example, the model specified here sets `cov_a`, `cov_b`, and `cov_c` as covariates on the baseline response:

```{r}
full_model <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure), # structural model
  e0   ~ 1 + cov_a + cov_b + cov_c, # covariate model for baseline
  emax ~ 1,                         # covariate model for max response
  ec50 ~ 1,                         # covariate model for EC50
  nl = TRUE
)
```

### Continuous response data

To apply this model to the continuous data, pass the `full_model` along with `parameter_prior` and `gaussian_measurement` to `brm()`:

```{r}
#| label: run-continuous-emax-model-with-covariates
#| message: false
#| results: hide
continuous_full_fit <- brm(
  formula = full_model, 
  family = gaussian_measurement, 
  data = d_example_emax_3cov, 
  prior = parameter_prior
) 
```

Printing the `continuous_full_fit` object provides summary information about the regression coefficients for the covariates and other parameters:

```{r}
continuous_full_fit
```

Extending the data visualization used earlier, the model predictions can be plotted as a function of both `exposure` and `cov_a`:

```{r}
continuous_full_fit |> 
  epred_draws(newdata = expand_grid(
    exposure = seq(0, 50000, 1000),
    cov_a = c(2, 5, 8), 
    cov_b = 5,
    cov_c = 5
  )) |> 
  median_qi() |> 
  ggplot(mapping = aes(exposure, .epred)) + 
  geom_path() + 
  geom_ribbon(
    mapping = aes(ymin = .lower, ymax = .upper), 
    alpha = 0.3
  ) +
  geom_point(
    data = d_example_emax_3cov |> 
      mutate(
        cov_a_raw = cov_a,
        cov_a = case_when(
          cov_a < 3.5 ~ 2,
          cov_a >= 3.5 & cov_a < 6.5 ~ 5,
          cov_a >= 6.5 ~ 8
        )
      ),
    mapping = aes(y = response, color = cov_a_raw)
  ) + 
  facet_wrap(~cov_a) +
  labs(color = "cov_a") + 
  theme(legend.position = "bottom")
```

### Binary response data

To examine the structure of the data set, create an exploratory visualization:

```{r}
#| label: show-binary-emax-data
#| fig-height: 8
#| fig-width: 8

d_example_emax_bin_3cov |> 
  pivot_longer(
    cols = c(exposure, cov_a, cov_b, cov_c), 
    names_to = "variable",
    values_to = "value"
  ) |> 
  mutate(response = factor(response)) |> 
  ggplot(aes(response, value)) + 
  geom_violin(draw_quantiles = .5) + 
  facet_wrap(~ variable, scales = "free_y")
```

The same approach can be used when the response variable is binary. As before, the only difference from the continuous model is the use of the `bernoulli_measurement` model:

```{r}
#| label: run-binary-emax-model-with-covariates
#| message: false
#| results: hide
binary_full_fit <- brm(
  formula = full_model, 
  family = bernoulli_measurement, 
  data = d_example_emax_bin_3cov, 
  prior = parameter_prior
) 
```

Results for this model are shown below: 

```{r}
binary_full_fit
```

The data visualization for this model is shown below:

```{r}
binary_full_fit |> 
  epred_draws(newdata = expand_grid(
    exposure = seq(0, 50000, 1000),
    cov_a = c(2, 5, 8), 
    cov_b = 5,
    cov_c = 5
  )) |> 
  median_qi() |> 
  ggplot(mapping = aes(exposure, .epred)) + 
  geom_path() +
  geom_ribbon(
    mapping = aes(ymin = .lower, ymax = .upper), 
    alpha = 0.3
  ) +
  geom_jitter(
    data = d_example_emax_bin_3cov |> 
      mutate(
        cov_a_raw = cov_a,
        cov_a = case_when(
          cov_a < 3.5 ~ 2,
          cov_a >= 3.5 & cov_a < 6.5 ~ 5,
          cov_a >= 6.5 ~ 8
        )
      ),
    mapping = aes(y = response, color = cov_a_raw),
    width = 0,
    height = .05
  ) + 
  facet_wrap(~cov_a) +
  labs(color = "cov_a") + 
  theme(legend.position = "bottom")
```

## Covariates on other parameters

The previous two examples illustrate covariates placed on the intercept parameter `e0`. It is possible to define covariate models on any parameter within the E~max~ model. 

```{r}
other_covariates <- brmsformula(
  response ~ e0 + emax * exposure / (ec50 + exposure), # structural model
  e0   ~ 1 + cov_a,   # covariate model for baseline
  emax ~ 1 + cov_b,   # covariate model for max response
  ec50 ~ 1,           # covariate model for EC50
  nl = TRUE
)
```

```{r}
#| label: run-other-covariates-emax-model
#| message: false
#| results: hide
other_covariates_fit <- brm(
  formula = other_covariates, 
  family = gaussian_measurement, 
  data = d_example_emax_3cov, 
  prior = parameter_prior
) 
```

Printing the `other_covariates_fit` object provides summary information:

```{r}
other_covariates_fit
```

## Model comparison

The brms package provides a flexible interface for model comparison using LOO-CV and WAIC, using the [loo](http://mc-stan.org/loo/) package internally. One workflow for calling this interface is illustrated in this section, using the two continuous-response E~max~ models as the example case. The first step is to use `add_criterion()` to run the LOO-CV procedure, and store the results internally within the brmsfit object:

```{r}
continuous_full_fit <- add_criterion(continuous_full_fit, "loo")
continuous_base_fit <- add_criterion(continuous_base_fit, "loo")
```

If necessary, the stored criterion results can be extracted from a model object as shown below:

```{r}
continuous_full_fit$criteria$loo
```

To compare two models that contain stored criterion results, use `loo_compare()`:

```{r}
continuous_loo_compare <- loo_compare(continuous_full_fit, continuous_base_fit)
continuous_loo_compare
```

By default the printed output shows the most important columns, but the return value from `loo_compare()` contains additional information relevant to the model comparison. To view all columns, call the print method with `simplify = FALSE`:

```{r}
print(continuous_loo_compare, simplify = FALSE)
```


